<div style="text-align: left;">
One of the most important things you can learn in programming is Clean Code.
<br>
Writing bad code can make things more complicated than they really are and forces you to spend so much time
trying to figure out what one piece of code does before actually doing any work.
<br>
<br>
This situation can be solved by executing one piece of code and giving it the proper data to process but 
what if you don't even know what is the data input and the piece of code has like 100 lines with one for loop
behind the other and some times one for loop inside the other with lots of if else statements?
That makes things a little bit harder, isn't? 

#Long line break
<br>
<br>
# Long line break

Today i'm going to show you how I go through this refact process almost everyday actually using my own code as an example
and using recommendations from the book <a href="https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship-ebook/dp/B001GSTOAM" targe="blank">
Clean Code></a>

#Long line break
<br>
<br>
# Long line break

<h3>Static Project: understanding the idea</h3>
<a href="https://github.com/GabrielSlima/Static-Project" target="blank">Static Project</a> was one of my first public projects and
It was intented to create blogs main pages and blog posts for me. Something like this:
<img class="post-img" src="images/clean-code-meaningful-names/static_proect_demo.png">
<img class="post-img" src="images/clean-code-meaningful-names/static_proect_demo_post.png">

A very simple idea with a very simple implementation which made this project a perfect way 
for applying concepts like OOP and learn the basics of a new programming language.
<br>
This project being one of the first projects of mine is perfect to show you how I could make things better and clear.
#Long line break
<br>
<br>
# Long line break

Following the documentation it seems that main.py controls the user input and give us the possibility to create a new project or a new 
blog post:
<div class="code-snipppet">
python3 main.py <COMMAND> <COMMAND_ARGUMENTS>
</div>

Lets try this:
<br>
On my computer I'll open my terminal and clone the project:
<img class="post-img" src="images/clean-code-meaningful-names/project_download.gif">

Let's execute the command to create a new project as said in the doc:
<img class="post-img" src="images/clean-code-meaningful-names/new_project.gif">

And that's what we have inside the project's folder:
<img class="post-img" src="images/clean-code-meaningful-names/project_structure.gif">

And there it is, the main page:
<img class="post-img" src="images/clean-code-meaningful-names/project_main_page.gif">

Let's try to create a new blog post to see what happens:
<img class="post-img" src="images/clean-code-meaningful-names/new_blog_post.gif">
<img class="post-img" src="images/clean-code-meaningful-names/blog_post_visualization.gif">

#Long line break
<br>
<br>
# Long line break

It seems to be working the way it was supposed to...now let's analyse the core code an start working:
<img class="post-img" src="images/clean-code-meaningful-names/writer-typing.gif">

#Long line break
<br>
<br>
# Long line break


<h3>The big questions</h3>
The Clean Code book recommends that when choosing the name of a class, 
function or variable we should have in mind at least the following big questions:
<u>
<li>Why it exists?</li>
<li>What it does?</li>
<li>How it is used?</li>
</ul>
So following this Idea, let's get the file <a href="#main_first_code_snippet">main.py</a> and explore the content
trying to answer those questions and understand the meaning beahind each coded line:
<div class="code-snipppet">
    from generate import gerador
    import sys, json, datetime
    if len(sys.argv) < 3:
        print('Insira argumentos validos por favor...\n\n')
        print('''Modo de usar:\nCRIAR UM NOVO PROJETO \t\t novo NOME_PROJETO\nCRIAR UM NOVO POST\t\tpost NOME_DO_POST PASTA_DO_PROJETO''')

    else:
        
        #A OPCAO SERA O PRIMEIRO ARGUMENTO
        argumento = sys.argv[1]

        #SERA O SEGUNDO A PASTA OU NOME DO POST
        pasta_nome_post = sys.argv[2]


        if argumento.lower() == 'novo' and pasta_nome_post != " ":
            print("Tentando gerar arquivos...")

            #INSTANCIAMOS A CLASSE PASSANDO OS ARGUMENTOS
            projeto = gerador(argumento, pasta_nome_post + '/')

            #SE A RESPOSTA FOR TRUE
            if projeto:
                print('Feito')  
        if argumento.lower() == 'ajuda':
            print('''Modo de usar:\n\n CRIAR UM NOVO PROJETO \t\t novo NOME_PROJETO\nCRIAR UM NOVO POST\t\tpost NOME_DO_POST PASTA_DO_PROJETO''')
        #SE O ARGUMENTO FOR POST, O NOME DO POST DEVE SER PASSADO JUNTO A PASTA DO PROJETO  

            
        if argumento.lower() == 'post' and pasta_nome_post != " " and sys.argv[3] != " " and sys.argv[4] != " ":
            print("Gerando arquivos...")
            #PRIMEIRO SERA INSERIDO, O POST, NO JSON
            #ABERTURA DO ARQUIVO EM MODO ESCRITA/LEITURA
            pasta_destino = sys.argv[3]
            categoria = sys.argv[4]  
            try:
                files = open(str(pasta_destino) + '/data.json', 'r+')
                #LEITURA DO ARQUIVO
                leitura = files.read()
                #PASSANDO DE JSON PARA PARA ALGO QUE O PYTHON ENTENDA, GERALMENTE, LISTA, DICIONARIOS ETC.
                dados = json.loads(leitura)
                    
                #INSTANCIA DA CLASS DATETIME
                agora = datetime.datetime.now()

                #ATRIBUIÇÃO DE UM NOVO POST COM DADOS GENERICOS
                dados[1]['posts'][pasta_nome_post] = {"title": "titulo do post", "categoria": str(categoria),"Data": str(agora.day) + '/' + str(agora.month) + '/' + str(agora.year), "conteudo": "SEU CONTEUDO DEVE SER INSERIDO AQUI"}
                    
                files.seek(0)

                #"OFICIALIZANDO" AS ALTERAÇOES DO JSON DANDO UM DUMP, NADA MAIS É DO QUE GERAR O NOVO BINARIO JSON
                json.dump(dados, files, indent = 4)

                files.truncate()
                #ISNTANCIA DA CLASSE GENERATE, TAIS ARGUMENTOS DEVEM SER PASSADOS
                postagem = gerador(" "," ")
                post = postagem.newPost(pasta_nome_post, str(pasta_destino),categoria)
                if post:
                    print('Feito') 
        
            except FileNotFoundError:
                print('Talvez o diretorio informado não exista.') 
</div>

<h4>Understanding the imports</h4>
Right at the beginning of the code we can see that the first import uses 2 different languages. This probably isn't gonna
happens if your native language is English. But make sure that if you're using a language, stick with it to make things easier.
<br>
That being said, we can see that the first import is about the class that actually process the commands sent by the user, the following
imports are <b>sys</b> a module to interact with the Python interpreter, <b>json</b> module to represent and manipulate data in Json Objects
and <b>datetime</b> to manipulate date and time.
<br>
There is also a <b>if</b> statement to check if there's the minimum amount of arguments for to the script has been provided, 
if not, it shows the documentation.
<br>
So answering the big questions for the imports:
<ul>
 <li>generate.gerador: imports the class that is going to process the commands provided by the user</li>
 <li>sys: used to interact with the users through command line</li>
 <li>json: used to manipulate the configuration files</li>
 <li>datetime: used to dinamycally flag the creation date of a post</li>
</ul>

<h4>Understanding the first <b>if statement</b></h4>
<ul>
 <li>it garantees that the user only gives the script at the minimum 3 arguments</li>
 <li>it shows a summary of how to use the script using the function <b>print</b></li>
</ul>
Refacting the code for the first time:

<div class="code-snipppet">
    import core
    import sys
    import json
    import datetime
    import logging

    MINIMUM_COMMAND_LINE_ARGS = 3
    MAX_COMMAND_LINE_ARGS = 5

    USAGE_SUMMARY = """
    How to use ->
    python3 main.py <COMMAND> <COMMAND_ARGUMENTS>
    Create a new project: python3 main.py new <PROJECT_NAME>
    Create a new blog post: python3 main.py post <POST_NAME> <PROJECT_NAME> <POST_CATEGORY>
    """

    if len(sys.argv) < MINIMUM_COMMAND_LINE_ARGS or len(sys.argv) > MAX_COMMAND_LINE_ARGS:
        invalid_arguments_message = """
        Invalid amount of arguments, please try again with: \n {usage_summary}
        """
        
        invalid_arguments_message = invalid_arguments_message.format(
            usage_summary=USAGE_SUMMARY
        )
        
        logging.info(invalid_arguments_message)
</div>

Now we can see that if there's not the minimum or there's more than 5 arguments to deal with, a default error message 
will be shown along with the summary of the basic usage guide and let the user know how to properly use the scrpit.

#Long line break
<br>
<br>
# Long line break

But we still have some issues, what if it's passed 4 arguments? The verification doesn't cover that. Let's refact again

<div class="code-snipppet">
    import core
    import sys
    import json
    import datetime
    import logging

    AVAILABLE_FLOWS = {
        "new": {
            "arguments": [
                "project_name"
            ],
            "processor": core.create_new_project
        },
        "post": {
            "arguments": [
                "post_name",
                "project_name",
                "post_category"
            ],
            "processor": core.create_new_post
        }
    }
    MINIMUM_COMMAND_LINE_ARGS = 1
    FLOW_POSITION = 1
    SCRIPT_NAME = 1

    USAGE_SUMMARY = """
    How to use ->
    python3 main.py <COMMAND> <COMMAND_ARGUMENTS>
    Create a new project: python3 main.py new <PROJECT_NAME>
    Create a new blog post: python3 main.py post <POST_NAME> <PROJECT_NAME> <POST_CATEGORY>
    """

    def exit_program():
        invalid_arguments_message = """
        Invalid amount of arguments, please try again with: \n {usage_summary}
        """
        invalid_arguments_message = invalid_arguments_message.format(
            usage_summary=USAGE_SUMMARY
        )
        logging.info(invalid_arguments_message)
        sys.exit(1)

    user_input = sys.argv

    if (len(user_input) -SCRIPT_NAME < MINIMUM_COMMAND_LINE_ARGS or 
            not AVAILABLE_FLOWS.get(user_input[FLOW_POSITION])):
        exit_program()

    if len(user_input) -SCRIPT_NAME != len(AVAILABLE_FLOWS.get(user_input[FLOW_POSITION])):
        exit_program()
</div>

I think it's a good idea to see the possible behaviors as <b>flows</b>. We can have the <b>new project</b> flow,
<b>new post</b> flow and the <b>help</b> flow. New flows could be added eventually like a <b>list created posts</b> flow
with the possibility of seing the amount of posts created for a specific category and so on.
<br>
Have in mind that the first argument will be the script itself <b>main.py</b>, the second one will be the flow.
<br>
Now we garantee that the default message will be displayed:
<ul>
  <li>When the user gives the script less than 2 arguments</li>
  <li>when the user gives the script a flow that does not exists</li>
  <li>When the user gives the script the minimum amount of arguments but not enough arguments to complete the flow or
      gives more arguments than expected
  </li>
</ul>

<h4>Understanding the <b>else statement</b></h4>
Lets take a look into the <b>else</b> block. I'm going to break this one in two parts:
<div class="code-snippet">
    else:
        
        #A OPCAO SERA O PRIMEIRO ARGUMENTO
        argumento = sys.argv[1]

        #SERA O SEGUNDO A PASTA OU NOME DO POST
        pasta_nome_post = sys.argv[2] 


        if argumento.lower() == 'novo' and pasta_nome_post != " ":
            print("Tentando gerar arquivos...")

            #INSTANCIAMOS A CLASSE PASSANDO OS ARGUMENTOS
            projeto = gerador(argumento, pasta_nome_post + '/')

            #SE A RESPOSTA FOR TRUE
            if projeto:
                print('Feito')  
        if argumento.lower() == 'ajuda': # Create an output to the user with the documentation
            print('''Modo de usar:\n\n CRIAR UM NOVO PROJETO \t\t novo NOME_PROJETO\nCRIAR UM NOVO POST\t\tpost NOME_DO_POST PASTA_DO_PROJETO''')
        #SE O ARGUMENTO FOR POST, O NOME DO POST DEVE SER PASSADO JUNTO A PASTA DO PROJETO  
</div>
Right at the beginning we have two variables, one to store the <b>flow</b> chosen by the user and the second one to store
the project/post name.
<br>
The first <b>if</b> statement deals with the <b>new project</b> flow and garantees that the project name is not empty.
The second one verifys if the user typed <b>help</b> and shows the documentation if so.
<br>

So making some changes:
<div class="code-snippet">
    import core
    import sys
    import json
    import datetime
    import logging

    AVAILABLE_FLOWS = {
        "new": {
            "arguments": [
                "project_name"
            ],
            "processor": core.create_new_project
        },
        "post": {
            "arguments": [
                "post_name",
                "project_name",
                "post_category"
            ],
            "processor": core.create_new_post
        }
    }
    MINIMUM_COMMAND_LINE_ARGS = 1
    FLOW_POSITION = 1
    SCRIPT_NAME = 1

    USAGE_SUMMARY = """
    How to use ->
    python3 main.py <COMMAND> <COMMAND_ARGUMENTS>
    Create a new project: python3 main.py new <PROJECT_NAME>
    Create a new blog post: python3 main.py post <POST_NAME> <PROJECT_NAME> <POST_CATEGORY>
    """

    def exit_program():
        invalid_arguments_message = """
        Invalid amount of arguments, please try again with: \n {usage_summary}
        """
        invalid_arguments_message = invalid_arguments_message.format(
            usage_summary=USAGE_SUMMARY
        )
        logging.info(invalid_arguments_message)
        sys.exit(1)

    user_input = sys.argv

    if (len(user_input) -SCRIPT_NAME < MINIMUM_COMMAND_LINE_ARGS or 
            not AVAILABLE_FLOWS.get(user_input[FLOW_POSITION])):
        exit_program()

    if len(user_input) -SCRIPT_NAME != len(AVAILABLE_FLOWS.get(user_input[FLOW_POSITION])):
        exit_program()

    processor = AVAILABLE_FLOWS[user_input[FLOW_POSITION]]['processor']
    processor(user_input[FLOW_POSITION + 1: ])
</div>

I basically removed the if statement since once the flow and the right amount of arguments is provided
by the user the processor will be called and the arguments will be passed to the core module.

That's it, lets analyse the last <b>if</b> statement inside the <b>else block</b> and see what's happening:
<div class="code-snippet">
else:
    if argumento.lower() == 'post' and pasta_nome_post != " " and sys.argv[3] != " " and sys.argv[4] != " ":
        print("Gerando arquivos...")
        #PRIMEIRO SERA INSERIDO, O POST, NO JSON
        #ABERTURA DO ARQUIVO EM MODO ESCRITA/LEITURA
        pasta_destino = sys.argv[3]
        categoria = sys.argv[4]  
        try:
            files = open(str(pasta_destino) + '/data.json', 'r+')
             #LEITURA DO ARQUIVO
            leitura = files.read()
            #PASSANDO DE JSON PARA PARA ALGO QUE O PYTHON ENTENDA, GERALMENTE, LISTA, DICIONARIOS ETC.
            dados = json.loads(leitura)
                
            #INSTANCIA DA CLASS DATETIME
            agora = datetime.datetime.now()

            #ATRIBUIÇÃO DE UM NOVO POST COM DADOS GENERICOS
            dados[1]['posts'][pasta_nome_post] = {"title": "titulo do post", "categoria": str(categoria),"Data": str(agora.day) + '/' + str(agora.month) + '/' + str(agora.year), "conteudo": "SEU CONTEUDO DEVE SER INSERIDO AQUI"}
                
            files.seek(0)

            #"OFICIALIZANDO" AS ALTERAÇOES DO JSON DANDO UM DUMP, NADA MAIS É DO QUE GERAR O NOVO BINARIO JSON
            json.dump(dados, files, indent = 4)

            files.truncate()
            #ISNTANCIA DA CLASSE GENERATE, TAIS ARGUMENTOS DEVEM SER PASSADOS
            postagem = gerador(" "," ")
            post = postagem.newPost(pasta_nome_post, str(pasta_destino),categoria)
            if post:
                print('Feito') 
    
        except FileNotFoundError:
            print('Talvez o diretorio informado não exista.')
</div>
As we can see, it's about the <b>new post</b> flow and it validates if all the required parameters are present and not empty.
Right in the sequence it opens the file <b>data.json</b> inside the existing project, reads it, loads the Json text and 
add a new dict object to it.
<br>
The <b>seek()</b> call is related to the stream position. I'm not getting too much into this today, 
but a simple explaination would be: Python offers a way to work with <b>stream postions</b> similary to 
<b>File Position pointers</b> in C. That would be a way to identify your position inside a file object.
<br>
The module being used in this case is the I/O through the built-in function <b>open()</b>. When the Json file is oppend a text stream
is stored. The <b>seek()</b> allow us to define where the operations (Input/output or Read/Write) will be started using the 
offset (beginning) informed as a reference.

#Long line break
<br>
<br>
# Long line break

Let's say that you have a file <b>cool_file.txt</b> with the text <b>Just a cool content for a cool file</b> and you wants to
print just the "cool file" part. Seek allow us to set the starting point, so our starting point would be the byte 26, translating
this, the function call would be <b>file.seek(26)</b>.
<br>

To make it more clear, let's take from the point where the file <b>cool_file.txt</b> was oppend and the content was stored.
The output would be something like this:
<img class="post-img" src="images/clean-code-meaningful-names/seek_example.png">

Let's translate this to a <a href="https://docs.python.org/3/library/functions.html#func-bytearray" target="blank">byte array</a>,
get the byte in the 26 position, get the hexadecimal represenation from the given decimal number and load the text again and see what happens:
<img class="post-img" src="images/clean-code-meaningful-names/seek_example_hex_to_text.png">
There it is, the "c" char. The char that will be used as a starting point to produce the <b>Read</b> operation and give us the expected output 
<b>cool file</b> part.

#Long line break
<br>
<br>
# Long line break

Getting back to the "why" of things, right after setting the starting point for the Write operation the oppened file receives the
updated valid json text with the <b>json.dupm()</b>.
<br>
The <a href="https://docs.python.org/3/library/io.html#io.IOBase.truncate" targe="blank">truncate()</a> is going to resize the stream 
to the current offset position which will be the last writed byte since any value is passed to it followed by the <b>gerador()</b> instance and the actually
page post page generator function call...

#Long line break
<br>
<br>
# Long line break

Now that we know what everything is doing, let's work on this pice of code:
To remove this validation we can just verify if any of the required arguments of the current flow are empty like this:
<div class="code-snippet">
    flow = AVAILABLE_FLOWS[user_input[FLOW_POSITION]]
    for index, required_argument in enumerate(flow['arguments']):
    if not user_input[index + (FLOW_POSITION + SCRIPT_NAME)].strip():
        exit_program()
</div>

The remaining code does not seems to follow the idea of the <b>main.py</b> file which would be to intermediate the 
core and the user's input so it makes more sense to remove it from there and put it inside the <b>core</b> module.
#Long line break
<br>
<br>
# Long line break

Finally we have the actual processor call where it's going to be easier since the processor reference is inside the 
<b>AVAILABLE_FLOWS</b> structure. All we have to do is to get the corresponding processor based on the flow name 
and provide the arguments.
<div class="code-snippet">
    processor = flow['processor']
    processor(user_input[(FLOW_POSITION + SCRIPT_NAME): ])
</div>

And the complete file would be:
<div class="code-snippet">
    import core
    import sys
    import json
    import datetime
    import logging

    AVAILABLE_FLOWS = {
        "new": {
            "arguments": [
                "project_name"
            ],
            "processor": core.Project
        },
        "post": {
            "arguments": [
                "post_name",
                "post_category",
                "project_name"
            ],
            "processor": core.Post
        }
    }
    MINIMUM_COMMAND_LINE_ARGS = 1
    FLOW_POSITION = 1
    SCRIPT_NAME = 1

    USAGE_SUMMARY = """
    How to use ->
    python3 main.py <COMMAND> <COMMAND_ARGUMENTS>
    Create a new project: python3 main.py new <PROJECT_NAME>
    Create a new blog post: python3 main.py post <POST_NAME> <PROJECT_NAME> <POST_CATEGORY>
    """

    def exit_program():
        invalid_arguments_message = """
        Invalid amount of arguments, please try again with: \n {usage_summary}
        """
        invalid_arguments_message = invalid_arguments_message.format(
            usage_summary=USAGE_SUMMARY
        )
        logging.info(invalid_arguments_message)
        sys.exit(1)

    user_input = sys.argv

    if (len(user_input) -SCRIPT_NAME < MINIMUM_COMMAND_LINE_ARGS or 
            not AVAILABLE_FLOWS.get(user_input[FLOW_POSITION])):
        exit_program()

    if len(user_input) -SCRIPT_NAME != len(AVAILABLE_FLOWS.get(user_input[FLOW_POSITION])):
        exit_program()

    flow = AVAILABLE_FLOWS[user_input[FLOW_POSITION]]
    for index, required_argument in enumerate(flow['arguments']):
        if not user_input[index + (FLOW_POSITION + SCRIPT_NAME)].strip():
            exit_program()

    processor = flow['processor']
    processor(user_input[(FLOW_POSITION + SCRIPT_NAME): ])
</div>

#Long line break
<br>
<br>
# Long line break

We can go even further and organize this module like this:
<div class="code-snippet">
    import core
    import sys
    import json
    import datetime
    import logging

    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    handler = logging.StreamHandler()
    handler.setLevel(logging.INFO)
    logger.addHandler(handler)

    AVAILABLE_FLOWS = {
        "new": {
            "arguments": [
                "project_name"
            ],
            "processor": core.Project
        },
        "post": {
            "arguments": [
                "post_name",
                "post_category",
                "project_name"
            ],
            "processor": core.Post
        },
        "help": {
            "arguments": [],
            "processor": help 
        }
    }
    MINIMUM_COMMAND_LINE_ARGS = 1
    FLOW_POSITION = 1
    SCRIPT_NAME = 1

    def exit_program():
        invalid_arguments_message = "Invalid arguments..."
        logging.error(invalid_arguments_message)
        help()
        sys.exit(1)

    def handler(user_input):
        if (len(user_input) -SCRIPT_NAME < MINIMUM_COMMAND_LINE_ARGS or 
                not AVAILABLE_FLOWS.get(user_input[FLOW_POSITION])):
            exit_program()
            
        if len(user_input) -SCRIPT_NAME != len(AVAILABLE_FLOWS.get(user_input[FLOW_POSITION])):
            exit_program()

        flow = AVAILABLE_FLOWS[user_input[FLOW_POSITION]]
        for index, required_argument in enumerate(flow['arguments']):
            if not user_input[index + (FLOW_POSITION + SCRIPT_NAME)].strip():
                exit_program()

        processor = flow['processor']
        processor(user_input[(FLOW_POSITION + SCRIPT_NAME): ])

    def help():
        """Usage: 
        Basic structure: python3 main.py <FLOW> <FLOW_ARGUMENTS>
        Create a new project: python3 main.py new <PROJECT_NAME>
        Create a new blog post: python3 main.py post <POST_NAME> <POST_CATEGORY> <PROJECT_NAME>
        """
        logging.info(help.__doc__)

    if __name__ == "__main__":
        handler(sys.argv)
</div>

<h3>The core module</h3>
Now that the <b>main.py</b> has a better look, let's dive into the the <b>core.py</b> previously <b>generate.py</b>.
<div class="code-snippet">
    from template import hCSS
    import os, json
    Temp = hCSS()
    HTML = Temp.html
    JAVAS = Temp.javaS
    estiloCSS = Temp.estilo
    Json = Temp.json
    conteudoH = Temp.post_html
    conteudoJ = Temp.javaS_post
    List_dir_html = Temp.diretorio_list_html
    ListDirJs = Temp.diretorio_list_js
    class gerador():
        def __init__(self,arg,pasta):
            self.arg = arg
            self.pasta = pasta

            
            if self.arg.lower() == 'novo':
                self.gerar_projeto(self.pasta)

        def gerar_projeto (self, pasta):
            self.dir = os.path.dirname(pasta)
            self.bootstrap = os.path.dirname(self.dir+ '/bootstrap/')
            self.estilo = os.path.dirname(self.bootstrap +'/css/')
            self.content = os.path.dirname(self.dir + '/conteudo/')
            self.principal_content = os.path.dirname(self.dir + '/conteudo/principal/')

            #VERIFICAMOS SE A PASTA EXISTE
            if not os.path.exists(self.dir):

                #SE NÃO EXISTIR, VAMOS CRIA-LA
                os.makedirs(self.dir)
                #ABRIREMOS UM ARQUIVO DENTRO DO DIRETORIO, SE ELE NAO EXISTIR, CRIAMOS UM ARQUIVO INDEX DENTRO DO DIRETORIO E O ABRIREMOS
                self.index = open(self.dir + '/index.html', 'w+')

                #ESCREVEREMOS DENTRO DESSE ARQUIVO O TEXTO ESCRITO NO ARQUIVO TEMPLATE html
                self.index.write(HTML)

                #ABRIREMOS UM ARQUIVO DENTRO DO DIRETORIO. SE NAO EXISTIR, VAMOS CRIA-LO
                self.javascript = open(self.dir +'/java.js', 'w+' )
                

                #VAMOS ESCREVER O JAVASCRIPT VINDO DA PAGINA TEMPLATE
                self.javascript.write(JAVAS)

                # O MESMO ACONTECE COM O JSON
                self.j = open(self.dir +'/data.json','w+')
                self.j.write(Json)

                os.makedirs(self.principal_content)
                
                
                # #SE O DIRETORIO NAO EXISTIR
                if not os.path.exists(self.bootstrap):
                    os.makedirs(self.bootstrap)

                    #ENTRAR NA PASTA self.bootstrap/ BAIXAR O BOOTSTRAP/DESCOMPACTAR O BOOTSTRAP BAIXADO
                    os.system('cd ' + self.bootstrap + ' && wget https://github.com/twbs/bootstrap/releases/download/v4.1.2/bootstrap-4.1.2-dist.zip && unzip bootstrap-4.1.2-dist.zip')
                    self.arq = open(self.estilo + '/estilo.css', 'w+')
                    self.arq.write(estiloCSS)

                #CRIAR A PASTA CONTENT E INSERIR O JS DOS POSTS E DA LISTAGEM DE DIRETORIOS LÁ CASO O DIRETORIO CONTEUDO NAO EXISTA 
                if not os.path.exists(self.content):
                    os.makedirs(self.content)
                    self.js_post = open(self.content + '/js_post.js', 'w+')
                    self.js_post.write(conteudoJ)
                    self.js_dir_list = open(self.content + '/dir_list.js', 'w+')
                    self.js.dir_list.write(List_dir_js)

                #CASO ELE EXISTA VAMOS APENAS CRIAR/ ESCREVER OS CONTEUDOS NOS ARQUIVOS
                else: 
                    self.js_post = open(self.content + '/js_post.js', 'w+')
                    self.js_post.write(conteudoJ)
                    self.js_dir_list = open(self.content + '/dir_list.js', 'w+')
                    
                    self.js_dir_list.write(ListDirJs)
                    
            return True            


        #CRIAR POSTS
        def newPost(self, nome_post, pasta_proj, categoria):
            self.nome_post = nome_post
            self.pasta_proj = pasta_proj
            self.categoria = categoria
            self.caminho = self.pasta_proj + '/conteudo/' + self.categoria + '/'
            
            if not os.path.exists(self.caminho):
                os.makedirs(self.caminho)
                self.dir_list = open(self.caminho + categoria + '.html', 'w+')
                self.dir_list.write(List_dir_html)
                self.post = open(self.caminho + self.nome_post + '.html', 'w+')
                self.post.write(conteudoH)
            else:
                
                self.post = open(self.caminho + self.nome_post + '.html', 'w+')
                self.post.write(conteudoH)
            return True

</div>
<h4>Understanding the imports</h4>
This file has only 2 imports:
<ul>
    <li>from template import hCSS: imports the Html, Css and Js templates</li>
    <li>import os: used to manipulate the files inside project. Read and Write the the project's folder and so on</li>
    <li>import json: used to manipulate the Json template for the <b>data.json</b> file</li>
</ul>
One thing I usually do to make sure that I'm choosing the right name for my variable, at least for the moment, 
of course, is to review my own code after some hours, maybe even days or weeks. If I don't really know what the variable or even
the function is doing I just change the name to something that makes more sense on the moment and repeat the process
till eventually I come up with a more clear name. 
<br>
That's something that I usually do when I have some work to do with this piece of code specifically 
and I see the opportunity to make things better and more clear.  
<br>
<br>
<h3>Conclusion</h3>
Reacting your code (or someone else's code) can take some time and maybe the chosen names starts to lose the meaning or
reveals not to be as clear as you thought. It may take more than one refact process till the most appropriate name appears.
<br>
Even in when I was writing this blog post I changed the names that at first was making sense so many times. So don't be frustrated,
the more code you refact more senior you become.

Good Luck XD
</div>